(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{581:function(e,t,a){"use strict";a.r(t);var v=a(5),s=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[e._v("#")]),e._v(" 概念")]),e._v(" "),a("h2",{attrs:{id:"mvc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[e._v("#")]),e._v(" mvc")]),e._v(" "),a("ul",[a("li",[e._v("是model-view-controller的缩写；")]),e._v(" "),a("li",[e._v("model：是数据层，负责存储数据；")]),e._v(" "),a("li",[e._v("view：是视图层，用户所看到的页面")]),e._v(" "),a("li",[e._v("controller：是控制器，在协调层，负责协调model和view；根据用户在view上的动作在model上做出相应的更改，同时将更改的信息返回到view上")]),e._v(" "),a("li",[e._v("三者之间的关系，controller可以直接访问model，也可以直接控制view，但是model和view不能互相通信，相当于controller就是介于这两者之间的协调者；")])]),e._v(" "),a("h2",{attrs:{id:"mvvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[e._v("#")]),e._v(" mvvm")]),e._v(" "),a("ul",[a("li",[e._v("是model-view-viewModel的缩写")]),e._v(" "),a("li",[e._v("model：指后端传递的数据")]),e._v(" "),a("li",[e._v("view：指所看到的页面")]),e._v(" "),a("li",[e._v("viewModel：是mvvm模式的核心，它是连接view和model的桥梁")]),e._v(" "),a("li",[e._v("viewModel有2个方向：1、将model转换成view，即将后端传递的数据转化成所看到的页面，实现的方法是数据绑定；")]),e._v(" "),a("li",[e._v("2、将view转换成model，即将所看的页面转换成后端的数据，实现的方式是DOM事件监听；")]),e._v(" "),a("li",[e._v("这两个方向都实现，我们称之为数据的双向绑定；")])]),e._v(" "),a("h2",{attrs:{id:"webpack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[e._v("#")]),e._v(" webpack")]),e._v(" "),a("ul",[a("li",[e._v("loader：对源码的转换，处理非js模块：如css-loader，style-loader，运行在打包文件之前；")]),e._v(" "),a("li",[e._v("plugin：解决loader无法解决的问题，例如：图片压缩，在整个编译周期起作用")])]),e._v(" "),a("h2",{attrs:{id:"中间件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#中间件"}},[e._v("#")]),e._v(" 中间件")]),e._v(" "),a("ul",[a("li",[e._v("执行任何代码，修改请求响应，终结请求，调用栈堆中的下一个中间件；")])]),e._v(" "),a("p",[e._v("如果在调用post和get请求过程中的回调函数，函数没有写next()，就不会往下匹配，否则需要写next();")]),e._v(" "),a("h2",{attrs:{id:"koa和express的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#koa和express的区别"}},[e._v("#")]),e._v(" koa和express的区别")]),e._v(" "),a("ul",[a("li",[e._v("koa：是new一个，参数是ctx，next；如果里面有用到异步，需要在方法头增加async；返回内容是ctx.body=")]),e._v(" "),a("li",[e._v("express：是函数形式，参数是req，res，next。返回内容是res.send；")])]),e._v(" "),a("h2",{attrs:{id:"路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[e._v("#")]),e._v(" 路由")]),e._v(" "),a("ul",[a("li",[e._v("hash：url会加#，通过window.onhashChange去监听url的hash值，使用hashHishtory.push和hashHistory.replace；")]),e._v(" "),a("li",[e._v("history：通过window.popState得到路径变化，使用history.pushState()和history.replaceState；注意后端没有对应的路由处理，就会返回404；")])]),e._v(" "),a("h2",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[e._v("#")]),e._v(" redux")]),e._v(" "),a("p",[e._v("用redux时候，用到异步action，里面必须要使用dispatch，需要下载redux-thunk，在reducer，根据action赋值；")]),e._v(" "),a("p",[e._v("使用方法：")]),e._v(" "),a("ul",[a("li",[e._v("store.dispatch(actions);")]),e._v(" "),a("li",[e._v("增加数组格式：arr:[...state,action.info]")])]),e._v(" "),a("h2",{attrs:{id:"vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[e._v("#")]),e._v(" vuex")]),e._v(" "),a("ul",[a("li",[e._v("actions:可以执行异步，一个方法可以有很多个mutation，不能直接修改state的值；")]),e._v(" "),a("li",[e._v("mutation：必须执行同步方法，可以直接修改state；")]),e._v(" "),a("li",[e._v("modules：可以让每一个模块拥有自己的state、mutation、action、getters、使结构非常清晰，方便管理；")])])])}),[],!1,null,null,null);t.default=s.exports}}]);