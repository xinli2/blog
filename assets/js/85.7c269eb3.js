(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{603:function(t,e,a){"use strict";a.r(e);var s=a(5),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"小知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小知识点"}},[t._v("#")]),t._v(" 小知识点")]),t._v(" "),a("h2",{attrs:{id:"v-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-key"}},[t._v("#")]),t._v(" v-key")]),t._v(" "),a("p",[t._v('vue中列表循环需加:key="唯一标识" 唯一标识可以是item里面id index等，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM')]),t._v(" "),a("h2",{attrs:{id:"vue组件data为什么必须是函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue组件data为什么必须是函数"}},[t._v("#")]),t._v(" vue组件data为什么必须是函数")]),t._v(" "),a("p",[t._v("每一个vue组件都是一个vue实例，通过new Vue()实例化，引用同一个对象，如果data直接是一个对象的话，那么一旦修改其中一个组件的数据，其他组件相同数据就会被改变。而data是函数的话，每个vue组件的data都因为"),a("code",[t._v("函数有了自己的作用域")]),t._v("，互不干扰。")])])}),[],!1,null,null,null);e.default=r.exports}}]);